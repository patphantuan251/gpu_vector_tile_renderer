// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/shaders/generate_shaders.dart

const preludeShaders = <String, String>{
'interpolation': '''
#define data_crossfade(a, b) mix(a, b, camera.zoom - floor(camera.zoom))

#define data_step(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, step(end_stop, camera.zoom))

#define data_interpolate(start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, data_interpolate_factor(1.0, start_stop, end_stop, camera.zoom))

#define data_interpolate_exponential(base, start_value, end_value, start_stop, end_stop) \\
  mix(start_value, end_value, data_interpolate_factor(base, start_stop, end_stop, camera.zoom))

float data_interpolate_factor(
  float base,
  float start_stop,
  float end_stop,
  float t
) {
  float difference = end_stop - start_stop;
  float progress = t - start_stop;

  if (difference == 0.0) return 0.0;
  else if (base == 1.0) return progress / difference;
  else return (pow(base, progress) - 1.0) / (pow(base, difference) - 1.0);
}
''',
'tile': '''
precision highp float;

uniform Tile {
  highp mat4 local_to_world;
  highp float size;
  highp float extent;
  highp float opacity;
} tile;

uniform Camera {
  highp mat4 world_to_gl;
  highp float zoom;
  float pixel_ratio;
} camera;

vec4 project_tile_position(vec2 position) {
  return camera.world_to_gl * tile.local_to_world * (vec4(position * (tile.size / tile.extent), 0.0, 1.0));
}

float project_pixel_length(float len) {
  return len * tile.size / tile.extent;
}
''',
};

const vertexShaderTemplates = <String, String>{
'fill': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

in highp vec2 position;

#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

void main() {
  #pragma prop: resolve(...)
  gl_Position = project_tile_position(position + translate);
}
''',
'line': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

in highp vec2 position;
in highp vec2 normal;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

void main() {
  #pragma prop: resolve(...)

  // Width is defined in terms of screen pixels, so we need to convert it.
  float local_width = width * (tile.extent / tile.size);
  vec2 offset = normal * local_width * 0.5;
  gl_Position = project_tile_position(position + offset);
}
''',
'background': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

in highp vec2 position;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

void main() {
  #pragma prop: resolve(...)
  gl_Position = camera.world_to_gl * tile.local_to_world * vec4(position.x * tile.size, position.y * tile.size, 0.0, 1.0);
}
''',
'line-dashed': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile


in highp vec2 position;
in highp vec2 normal;
in highp float line_length;

out highp float v_line_length;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)
#pragma prop: declare(sampler2D dasharray)

void main() {
  #pragma prop: resolve(...)

  // Width is defined in terms of screen pixels, so we need to convert it.
  float local_width = width * (tile.extent / tile.size);
  vec2 offset = normal * local_width * 0.5;
  
  gl_Position = project_tile_position(position + offset);
  v_line_length = line_length;
}
''',
};

const fragmentShaderTemplates = <String, String>{
'background': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp float opacity)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  f_color = color * (opacity * tile.opacity);
}
''',
'line': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  f_color = color * (opacity * tile.opacity);
}
''',
'line-dashed': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

in highp float v_line_length;

#pragma prop: declare(highp vec4 color)
#pragma prop: declare(float opacity)
#pragma prop: declare(float width)
#pragma prop: declare(sampler2D dasharray)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  
  float line_position = project_pixel_length(v_line_length) / width;
  float dash_value = texture(dasharray, vec2(line_position / dasharray_size.x, 0.5)).r;
  if (dash_value < 0.5) discard;

  f_color = color * (opacity * tile.opacity);
}
''',
'fill': '''
#version 320 es
#pragma prelude: interpolation
#pragma prelude: tile

#pragma prop: declare(bool antialias)
#pragma prop: declare(highp float opacity)
#pragma prop: declare(highp vec4 color)
#pragma prop: declare(highp vec2 translate)

out highp vec4 f_color;

void main() {
  #pragma prop: resolve(...)
  f_color = color * (opacity * tile.opacity);
}
''',
};

